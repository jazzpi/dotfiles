#!/bin/bash
### jazzpi's bashrc
### ===============
### Separated into the following sections:
### 0. UTIL                 (utilities for the bashrc itself)
### 1. PROMPT               (setup for prompts)
### 2. COLORIZE             (color setup for various programs like ls, grep and gcc)
### 3. HISTORY              (setup for histories)
### 4. COMPLETION/EXPANSION (setup for shell completion and pathname expansion)
### 5. ENVIRONMENT/ALIASES  (environment variables and aliases)
### 6. MISC                 (everything else)

## UTIL

# Get actual directory the bashrc is in
# https://stackoverflow.com/a/246128
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
function cmd_exists {
    command -v "$1" &>/dev/null
}
function perr {
    >&2 echo $@
}

## PROMPT

# Green user@host, red if last command failed
_prompt_user='\`if [[ \$? = "0" ]]; then echo \"\\[\\033[1;32m\\]\"; else echo \"\\[\\033[1;31m\\]\"; fi\`\u@\h\[\033[0m\]'
# Cyan cwd
_prompt_dir='\[\033[36m\]\w\[\033[0m\]'
# Yellow [HH:MM:SS]
_prompt_time='\[\033[1;33m\]\t\[\033[0m\]'
# Git branch & status
function _prompt_git_branch {
    local branch=$(git symbolic-ref HEAD 2>/dev/null | cut -d"/" -f 3-)
    if [[ "$branch" ]]; then
        echo -n ":"
        # Green if clean, yellow if dirty
        if [[ -z $(git status -s) ]]; then
            echo -n "\[\033[32m\]"
        else
            echo -n "\[\033[33m\]"
        fi
        echo -n "$branch\[\033[0m\]"
    fi
}
PROMPT_COMMAND="PS1=\"╔═${_prompt_user} [${_prompt_dir}\$(_prompt_git_branch)]\n╚═${_prompt_time} $ \""
if [ "${VTE_VERSION:-0}" -ge 3405 ]; then
    # Set terminal title & PWD in xterm (and gnome-terminal)
    function _prompt_vte {
        [ "${VTE_VERSION:-0}" -ge 3405 ] || return
        # Replace $HOME with ~
        local pwd="${PWD/#$HOME/\~}"
        # Remove control characters
        pwd="${pwd//[[:cntrl:]]}"
        # Title
        echo -ne "\033]0;$USER@$HOSTNAME:$pwd\033\\"
        # PWD
        echo -ne "\033]7;file://$HOSTNAME$(/usr/lib/vte-urlencode-cwd)\033\\"
    }
    PROMPT_COMMAND="_prompt_vte;$PROMPT_COMMAND"
fi

## COLORIZE

# ls and grep
if cmd_exists dircolors ; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi
# GCC warnings/errors etc.
export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

## HISTORY

# Don't put duplicate or lines starting with space in the history
HISTCONTROL=ignoreboth
# Save more lines
HISTSIZE=5000
HISTFILESIZE=10000
# Append to history file, so we can share history across sessions
shopt -s histappend
# Save history after reading, but before executing a command
PS0="$PS0\$(history -a)"
# Reread history before showing the prompt
PROMPT_COMMAND="history -c; history -r; $PROMPT_COMMAND"

## COMPLETION/EXPANSION

# "**" in a pathname expansion will match files in all levels of subdirectories
shopt -s globstar
# Include hidden files in pathname expansion
shopt -s dotglob
# Enable programmable completion features
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

## ENVIRONMENT/ALIASES

. "$DIR/aliases.bash"
. "$DIR/ros.bash"
. "$DIR/crossplatform.bash"

## MISC

# Update LINES and COLUMNS after each command
shopt -s checkwinsize
# Make less more friendly for e.g. archive files, see lesspipe(1)
if cmd_exists lesspipe; then
    if lesspipe --version | grep -i gentoo &>/dev/null; then
        # Not Gentoo, we should simply be able to run lesspipe to set it up
        lesspipe >/dev/null
    else
        # Gentoo, we need to set up lesspipe manually
        export LESSOPEN="|lesspipe %s"
    fi
elif cmd_exists lesspipe.sh; then
    # Arch Linux, run to set up
    lesspipe.sh >/dev/null
fi
# Add an 'ag' function that behaves sort of like ag if it isn't installed
if ! cmd_exists ag; then
    function ag {
        grep -rni --exclude-dir build --exclude-dir .git -- "$@"
    }
fi

# Ensure that the last command in the bashrc was successful, so the prompt isn't red
true
